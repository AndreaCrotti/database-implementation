EXERCISE 5
#+SETUPFILE: group.org
#+STARTUP: showall

* TODO 
 DEADLINE: <2009-11-25 Mer>

* 1. SQL Isolation Levels
** 1. For each of the eight classes, describe a locking protocol that allows only transactions in this class. Does the locking protocol for a given class make any assumptions about the locking protocols used for other classes? Explain briefly
.
   The isolation levels are given in decreasing order of isolation, which corresponds to increasing order of concurrency level.
   Normally makes sense to keep a serializable isolation level, which avoids all the possible cause of inconsistency of the database.
   In some cases though it could be safe to lower the isolation level and get more performances due to an increased concurrency level.
   
   As we can see below the case of *read-only* access mode is actually equivalent to *read-write* case, just removing the possibility to acquire read locks on the resources.
# Same question was last year slide 8.

   |--------------+------+-----------------------------------------------------------------------------|
   | LEVEL        | MODE | SCHEDULER                                                                   |
   |--------------+------+-----------------------------------------------------------------------------|
   | SERIALIZABLE | RW   | S2PL                                                                        |
   | SERIALIZABLE | RO   | same as RW but not possible to grant write locks                            |
   | REP READ     | RW   | S2PL                                                                        |
   | REP READ     | RO   | same as RW but not possible to grant write locks                            |
   | READ COMM.   | RW   | Release immediately read locks and keep until the end write locks           |
   | READ COMM.   | RO   | Same as above but only regarding read locks                                 |
   | READ UNCOM.  | RW   | Not obtaining read locks before reading, keeping write locks until the end  |
   | READ UNCOM.  | RO   | Same as above but only regarding read locks                                 |

** 2. Consider a schedule generated by the execution of several SQL transactions. Is it guaranteed to be conflict serializable? To be final state serializable? To be recoverable?
   Without any further information  we can't say anything about the properties of the schedule, unless we have some requirements for the access-mode and isolation-level.

** 3. Consider a schedule generated by the execution of several SQL transactions, each of which has READ ONLY access-mode. Is it guaranteed to be conflict serializable? To be final state serializable? To be recoverable?
   If we set the access-mode to READ ONLY than there will not be any writing operation, thus we can guarantee that this schedule is conflict serializable, serializable and recoverable.

** 4. Consider a schedule generated by the execution of several SQL transactions, each of which has SERIALIZABLE isolation-level. Is it guaranteed to be conflict serializable? To be final state serializable? To be recoverable?
   A schedule generated in this way is always conflict serializable, final state serializable and recoverable.
   When a transaction is executed with the serializable isolation-level it guarantees that there will not be /dirty reads/, /nonrepeatable reads/ or /phantoms/.
# This is also what is generated with 2PL

** 5. For each combination determine whether the following anomalies will occur: inconsistent read, dirty read, lost update, and phantom.
   Only the case where /access mode/ is set to /READ WRITE/ is interesting, given that only write operations can cause inconsistencies.
   
   | LEVEL/VIOLATION  | DIRTY READ | NONREPEATABLE READ | PHANTOM |
   |------------------+------------+--------------------+---------|
   | READ UNCOMMITTED | YES        | YES                | YES     |
   | READ COMMITTED   | NO         | YES                | YES     |
   | REPEATABLE READ  | NO         | NO                 | YES     |
   | SERIALIZABLE     | NO         | NO                 | NO      |


* 2. Crash Recovery
  In general in the *Analysis* we start from the most recent checkpoint and proceed until the last log record.
  We determine:
  - point where to start
  - dirty pages in the buffer spool at moment of crash
  - transactions that were active
  
  DPT and active transactions are then useful to see what must be done later.

** 1. What is done during Analysis after the first restart? (Be precise about the points at which Analysis begins and ends and describe the contents of any tables constructed in this phase.)
   - Begins at LSN 1 and ends at LSN 10
   - Tables constructed are: The Dirty Page Table (DPT) and the Transaction Table.
   Dirty Page Table contains:

    | pageID | recLSN |
    |--------+--------|
    | P1     |      2 |
    | P2     |      3 |
    | P3     |      6 |
    | P5     |      9 |

   Transaction Table contains:
   
  | transID | lastLSN | status |
  |---------+---------+--------|
  | T1      |       9 | U      |
  | T3      |      10 | U      |
   
** 2. What is done during Redo after the first restart? (Be precise about the points at which Redo begins and ends.)

   - Redo begins at the oldest LSN found in the DPT, so in this case its LSN 2 and ends at LSN 10
   - Redo is now rewriting all updates or CLRs, meaning : LSN 2,3,6,7,9

** 3. What is done during Undo between the first restart and the second restart? (Be precise about the points at which Undo begins and ends.)

   - Undo begins at LSN 10, undoing all Transactions which have the status U in the transaction table.
      - write CLR for LSN 9 in LSN 11
      - write CLR for LSN 7 in LSN 12
   - the system crashes again.

** 4. What is the log at the beginning of the second restart? What is done during Analysis after the second restart?
    - everything´s the same plus LSN 11 containing a CLR for LSN 9 and LSN 12 containing a CLR for LSN 7.

** 5. What is done during Redo after the second restart?
    - All that has been done in the first redo plus:
    - Redoing the two CLRs, meaning the pages affected by the CLR (so the the undo-process) are set to the value of the CLR and therefore completing the undoing process, in case the CLR was not written to the disk.

** 6. What is done during Undo between the second restart and the third restart?
   - Going on with the undo (beginning at LSN 6): 
   - write CLR for LSN 6 in LSN 13 
   - write CLR for LSN 3 in LSN 14

** 7. What is the log at the beginning of the third restart? What is done during Analysis after the third restart?
   - see old table plus entries of 3) and 6) .
   - Analysis starts at LSN 1 again doing the same as in first analysis. The new CLR records will be added to the Dirty Page Table 

** 8. What is done during Redo of the third restart?
   - Redoing everything like first Redo, starting at LSN 1 and also including the new CLRs.

** 9. What is done during Undo of the third restart?
  - Now the undoing can be finished (we've already undone all necessary records except for LSN 1. So there´s another CLR written to the log containing the LSN 1. 
  - Now the set of LSNs to be undone is empty and the undoing process is finished.
  - Note that T2 was not undone as it was committed and ended during the Redo-process.
