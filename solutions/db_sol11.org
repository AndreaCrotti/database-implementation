EXERCISE 11
#+SETUPFILE: options.org

* Exercise 11.1
  Datalog program D without negation, prove the following:

** 1.

** 2.

** 3.

** 4.

** 5.

** 6.

** 

* Exercise 11.2
  Given the following Datalog program and the query q(X) :âˆ’ rel(12,X).

#+begin_src prolog
  %% Rule system
  rel(X,U) :- link(X,U).
  rel(X,U) :- link(X,Z),rel(Z,U).
  tie(X,Y) :- rel(X,U),rel(Y,U),x<>y.
  %% Facts
  link(1,12) link(2,12) link(2,23) link(3,23) link(12,127) link(7,127) link(0,1)
#+end_src

** 1. Evaluate the query using semi-naive bottom-up approach.
# For Naive see chapter 3 pag. 26 and page 30
   We generate also all implicit facts that are not useful.
#+begin_src dot :file es11_2_1.pdf :cmdline -Tpdf :exports none :results silent
   digraph G {
   t0 [ label = "link(1,12)" ];
   t1 [ label = "link(2,12)" ];
   t2 [ label = "link(2,23)" ];
   t3 [ label = "link(3,23)" ];
   t4 [ label = "link(12,127)" ];
   t5 [ label = "link(7,127)" ];
   t6 [ label = "link(0,1)" ];
   t7 [ label = "rel(12,127)" ];
   t8 [ label = "q(127)" ];
   t4 -> t7 -> t8;
   }
#+end_src
   
   [[file:es11_2_1.pdf]]

** 2. Evaluate the query using top-down approach. Draw the proof tree
#+begin_src dot :file es11_2_2.pdf :cmdline -Tpdf :exports none :results silent
   digraph G {
	   t0 [ label = "q(X) :- rel(12,X)" ];
	   t1 [ label = "rel(12, U) :- link(12, U) [X/12]" ];
           t2 [ label = "link(12,127) [U/127]" ];
           t3 [ color="red", shape="box", label = "verified, so X = 127" ];
           t0 -> t1 -> t2 -> t3;
   }
#+end_src
   
   [[file:es11_2_2.pdf]]

** 3. What are the pros and cons of top-down evaluation and bottom-up evaluation?
   Top-down evaluation starts from the query and try to reach a fact constructing a tree, and using backtracking until all the possible branches have been explored.
   It unifies variables at every step and it's very efficient if the query is well posed, but it could be very inefficient (or not terminate) in case some subtrees don't lead to a leaf.

   Bottom up evaluation instead
