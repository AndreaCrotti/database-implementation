EXERCISE 11
#+SETUPFILE: options.org

* Exercise 11.1
  Datalog program D without negation, prove the following:

** 1. We assume M1 \bigcap is not a model.
    Then there is a ground rule r: A \leftfree A1, A2,...An, which is false. A and Ai are positive literals.
    r is false means that Ai is in M1 \bigcap M2 while A is not.
    So we get Ai \in M1 and Ai \in M2.
    Since M1 is a model, A should also be in M1. So the rule r is true in M1.
    The same we get A \in M2 too.
    There is a contradiction with the assumption that A \notin M1 \bigcap M2, which means M1 \bigcap M2 is a model.

** 2. We assume there are more than one minimal models, Let's say M1 \nequal M2.
    According to 1, we get M = M1 \bigcap M2 is also a model.
    So we could get that M \subset M1 or M \subset M2 since M1 \nequal M2.
    Thus M1 or M2 is not minimal. There is a contradiction.

** 3. We assume F is a fixpoint, but not a model.
    So TD(F) = F and there is a ground rule r: A \leftfree A1, A2,...An, that is false in F.
    Then F \vDash Ai \wedge F \nvDash A.
    Consider TD(F) and r, by definition of immediate consequence operator we get that TD(F) \vDash A.
    TD(F) \nequal F, this is a contradiction.

    There are some models which are not fixpoints. For example, we have the facts F: q(a,b), q(b,a), t(b) and rule R: p(X) \leftfree q(X,Y), t(Y). We could have a model M: q(a,b), q(b,a), q(b,b), t(b), p(a), p(b). This model is not a fixpoint because fixpoint is generated by the facts and rule. And q(b,b) is a component of the Herbrand base, but can not be generated by the current F and R.

** 4. 

** 5.

** 6.

** 

* Exercise 11.2
  Given the following Datalog program and the query q(X) :âˆ’ rel(12,X).

#+begin_src prolog
  %% Rule system
  rel(X,U) :- link(X,U).
  rel(X,U) :- link(X,Z),rel(Z,U).
  tie(X,Y) :- rel(X,U),rel(Y,U),x<>y.
  %% Facts
  link(1,12) link(2,12) link(2,23) link(3,23) link(12,127) link(7,127) link(0,1)
#+end_src

** 1. Evaluate the query using semi-naive bottom-up approach.
# For Naive see chapter 3 pag. 26 and page 30
   We generate also all implicit facts that are not useful.
     rel (1,12), rel (1,127), rel (2,12), rel (2,127), rel (2,23), rel (3,23), rel (12, 127), rel (7,127), rel (0,1),   
     rel (0,12), rel (0,127).
     tie (1,2), tie (0,1), tie (0,2), tie (2,1), tie (1,0), tie (2,0), (12,7), tie (7,12), tie (0,7), tie (7,0),
     tie (1,7), tie (7,1), tie (2,7), tie (7,2), tie (2,3), tie (3,2).

   The answer to the query is: X= 127.

#+begin_src dot :file es11_2_1.pdf :cmdline -Tpdf :exports none :results silent
   digraph G {
   t0 [ label = "link(1,12)" ];
   t1 [ label = "link(2,12)" ];
   t2 [ label = "link(2,23)" ];
   t3 [ label = "link(3,23)" ];
   t4 [ label = "link(12,127)" ];
   t5 [ label = "link(7,127)" ];
   t6 [ label = "link(0,1)" ];
   t7 [ label = "rel(12,127)" ];
   t8 [ label = "q(127)" ];
   t4 -> t7 -> t8;
   }
#+end_src
   
   [[file:es11_2_1.pdf]]

** 2. Evaluate the query using top-down approach. Draw the proof tree
#+begin_src dot :file es11_2_2.pdf :cmdline -Tpdf :exports none :results silent
   digraph G {
	   t0 [ label = "q(X) :- rel(12,X)" ];
	   t1 [ label = "rel(12, U) :- link(12, U) [X/12]\n(we apply the rules in the given order)" ];
           t2 [ label = "link(12,127) [U/127]" ];
           t3 [ color="red", shape="box", label = "verified, so X = 127" ];
           t0 -> t1 -> t2 -> t3;
   }
#+end_src
   
   [[file:es11_2_2.pdf]]
   
** 3. What are the pros and cons of top-down evaluation and bottom-up evaluation?
   Top-down evaluation starts from the query and try to reach a fact constructing a tree, and using backtracking until all the possible branches have been explored.
   It unifies variables at every step and it's very efficient if the query is well posed, but it could be very inefficient (or not terminate) in case some subtrees don't lead to a leaf.

   Bottom up evaluation instead generates will try a finite number of algebraic steps to derive the goal.
   This will always terminate but in this process it will generate a large amount of implicit facts that could be avoided.
