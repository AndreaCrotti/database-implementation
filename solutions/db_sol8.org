EXERCISE 8
#+SETUPFILE: options.org
#+OPTIONS: \n:t

* 1. Query Languages	(5 pt.)
** 1. Assume that no two columns of relations have the same name.
   Show that a query in the normal form \pi_c(\sigma_F (R1 x R2 x ... x Rn)) can be expressed in Domain Relational Calculus (DRC), where c is a vector of columns, F is a boolean formula built from conjunctions of atoms in the form ci = cj or ci = constant (ci and ci are columns).
# Here on what field are we doing the join with on all the relations

** 2. What does “relational completeness” mean?
   Show that SQL is relational complete by enumerating SQL constructs corresponding to selection, projection, cartesian product, union, and difference.
   Give two examples of SQL constructs/semantics not expressible in relational algebra (RA).
   
   A language is /relational complete/ if it can express all possible queries expressible by RA.
   If we can map the RA operations to SQL constructs than we have shown that SQL is in fact relational complete.
   
# Why should be Join -> from??
   | selection  | where  |
   | projection | select |
   | Join       | from   |
   | union      | union  |
   | difference | except |
   
   SQL 

** 3.  Suppose we have three tables VIP(id), Employee(id), and Male(id). Translate the following SQL query into relational calculus and relational algebra.
   select Male.id from VIP, Employee, Male where VIP.id=Male.id or Employee.id=Male.id

*** Relational calculus   
**** Domain
     {id | \exists id VIP(id) \wedge Employee(id) \wedge Male(id) }
# we don't need other constraints given that the field has always the same name

**** Tuple
     m.id OF EACH m in Male:
     SOME v in VIP (Some e in Employee (m.id=v.id \vee m.id=e.id)

*** Relational algebra
    \pi_{Male.id}(\sigma_{Vip.id=Male.id \vee Employee.id=Mal.id}(VIP \times Employee \times Male)

** 4. For the following database (VIP is empty), what is the result of the query above? What is the result of \pi_{\phi}(Employee) (Employee)?
*** The result of the above query gives nothing as result, because the VIP table doesn't contain any tuple and the join becomes also empty.

#+begin_src sql
   CREATE table VIP(id INTEGER, PRIMARY KEY(id));
   CREATE table EMPLOYEE(id INTEGER, PRIMARY KEY(id));
   CREATE table MALE(id INTEGER, PRIMARY KEY(id));

   insert into MALE VALUES (1);
   insert into EMPLOYEE VALUES (1);
   insert into EMPLOYEE VALUES (2);

   select MALE.id
   from EMPLOYEE, MALE, VIP
   where VIP.id=MALE.id or EMPLOYEE.id=Male.id;
#+end_src

*** \pi_{\phi}(Employee) (Employee)
# This means projection over the empty set


** 5. Figure 1 shows the flow of a query through a DBMS, in which different forms are used to represent a query at different stages. Fill in the three blanks with the corresponding query languages (i.e., SQL, RC, RA).

** 2. What does “relational completeness” mean? Show that SQL is relational complete by enu- merating SQL constructs corresponding to selection, projection, cartesian product, union, and difference. Give two examples of SQL constructs/semantics not expressible in relational algebra (RA).

** 3.  Suppose we have three tables VIP(id), Employee(id), and Male(id). Translate the following SQL query into relational calculus and relational algebra.
select Male.id from VIP, Employee, Male where VIP.id=Male.id or Employee.id=Male.id

** 4. For the following database (VIP is empty), what is the result of the query above? What is the result of \pi_{\phi}(Employee) (Employee)?

** 5. Figure 1 shows the flow of a query through a DBMS, in which different forms are used to represent a query at different stages. Fill in the three blanks with the corresponding query languages (i.e., SQL, RC, RA).

* 2. Query Formulation (15 pt.)
Formulate the following queries as expressions in relational algebra, tuple relational calculus, domain relational calculus and SQL:
** a) Find name and city of all persons who work for the company 'MyComp' and earn less than 10000.
*** Relational Algebra:
    \pi_{person\_name, city} (\sigma_{company\_name='MyComp'\wedge salary <10000} ( lives \join works)
*** Tuple Calculus: {n.person\_name,n.city | lives(n) \wedge \exists y (\wedge works(y) n.person\_name = y.person\_name \wedge y.salary < 10000 \wedge y.company\_name='MyComp') }
*** Domain Calculuis:
    {p,c | \exists st(lives(p,c,st)  \wedge \exists f,g (works(p,f,g) \wedge g < 10000))}
 
 
** b) Find the names of all persons, who don't work for 'MyComp' (or do not work at all).
*** Relational Algebra:
    \pi_{person\_name}(lives) - \pi_{person\_name}(\sigma_{company\_name='MyComp'(works)})
 
*** Tuple Calculus:
    \{ p.person\_name | lives(p) \wedge \exists y \wedge works(y) (p.person\_name = y.person\_name \wedge y.company\_name != 'MyComp')\}
 
*** Domain Calculus:
    \{name | lives(name, _ , _) \wedge works(name, comp, _) \wedge comp != 'MyComp'\}
 
 
** c) Findthenamesofallpersons,wholiveinacitythatthecompanytheyareworkingforis not located in.
*** Relational Algebra:
    \pi_{person\_name} ( lives \join works \join (\pi_city (lives) X \pi_{company\_name}(works) - located))
 
*** Tuple Calculus:
    \{ p.person\_name | lives(p) \wedge \exists x \wedge works (x) \wedge \exists y \wedge located(y) ( p.person\_name = x.person\_name \wedge x.company\_name = y.company\_name \wedge y.city != p.city) \}
 
*** Domain Calculus:
    \{ p | lives (p,c,st) \wedge \exists works (p,f,g) \wedge \exists located(f,c_1) \wedge c != c_1
 
 
** d) Find the names of all managers, whose company is not placed in Munich or Hamburg.
*** Relational Algebra:
    \pi_{manager\_name}(boss)-(\pi_{manager\_name}(boss \join \pi_{manager\_name=person\_name}(works) \join ( \sigma_{city='Munich'} (located) U \sigma_{city='Hamburg'}(located))))

*** Tuple Calculus:
    \{m.manger\_name | boss(m) \wedge \exists x \wedge located(x) \exists y \wedge works(y) (m.manager\_name = y.person\_name \wedge x.city = y.city \wedge y.city != 'Hamburg' \wedge y.city != 'Munich')\}

*** Domain Calculus:
    \{ m | \exists p (boss (p,m) \ exists f,s located(f,s) \exists g (works (m,f,g) \wedge s != 'Munich' \wedge s != 'Hamburg'))\}



** e) Find the names of all companies that are located in exactly the same cities as 'MyComp', assuming each company is located in some city.
*** Relational Algebra:
    \pi_{company\_name} (\sigma_{C2='MyComp'\wedge city = city2}(located X p_{C2 \leftarrow company\_name}(p_{city2\leftarrow company\_name (located))))

*** Tuple Calculus:
    \{t(company\_name) | located (t) \wedge \neq (\exists l2)(located(l2) \wedge ( l2\[company\_name\] = t\[company\_name\]) \wedge \neq ((\exists myCL) (located(myCL) \wedge (myCL\[company\_name\] = 'MyComp') \wedge \neq(\exists l_2)(located(l_2) \wedge (l_2\[company\_name\] = t\[company\_name\]) \wedge (l_2\[city\] = myCL \[city\])))\}

*** Domain Calculus:
    \{ f | \exists s(located(f,s) \wedge located(myCompany, s) \wedge myComapny = 'MyComp')}
 
